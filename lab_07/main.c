/*Цель работы – построить и обработать хеш-таблицы, 
сравнить эффективность поиска в сбалансированных деревьях, 
в двоичных деревьях поиска и в хеш-таблицах. 
Сравнить эффективность устранения коллизий при внешнем и внутреннем хешировании.*/

/*Задание: 
построить хеш-таблицу по указанным данным. 
Сравнить эффективность поиска в сбалансированном двоичном дереве, в двоичном дереве поиска и в хеш-таблице (используя открытую и закрытую адресацию). 
Вывести на экран деревья и хеш-таблицы. 
Подсчитать среднее количество сравнений для поиска данных в указанных структурах. 
Произвести реструктуризацию хеш-таблицы, если среднее количество сравнений больше указанного. 
Оценить эффективность использования этих структур (по времени и памяти) для поставленной задачи. 
Оценить эффективность поиска в хеш-таблице при различном количестве коллизий и при различных методах  их разрешения.*/

/*Используя предыдущую программу (задача №6), сбалансировать полученное дерево. Вывести его на экран в виде дерева. 
Построить хеш-таблицу из чисел файла. Осуществить поиск введенного целого числа в двоичном дереве поиска, в сбалансированном дереве и в хеш-таблице. 
Сравнить время поиска, объем памяти и количество сравнений при использовании различных структур данных.*/


#include <stdio.h>
#include <stdlib.h>

#include "main.h" //структуры
#include "insert.h"//вставка зла в двоичное дерево
#include "apply.h"//пямой обход дерева
#include "getnum.h"//получение чисел из файла и создание дерева.
#include "createdot.h"//создание .gv файла
#include "tick.h"//замер времени.
#include "rotateright.h"//// правый поворот вокруг p
#include "rotateleft.h"// левый поворот вокруг q
#include "helpfunc.h"//вспомогательные функции для построения авл деревьев
#include "balance.h"//балансировка дерева
#include "insertavl.h"

void apply_balance(tree *tree)
{
  if (tree == NULL)
         return;

  apply_balance(tree->left);
  apply_balance(tree->right);
  printf("[%d]\n", tree->name);
  balance(tree);
}

int main(void)
{
  FILE *f;
  struct tree_node *root = NULL;

  f = fopen("in.txt","r");
  if(!f)
    printf("Can't open file\n");
  else
  {
    root = get_num(f);
    fclose(f);

    printf("\nПрямой обход: ");
    apply_pre(root, print, "%d ");

    apply_balance(root);
    printf("\nПрямой обход: ");
    apply_pre(root, print, "%d ");



  }

  f = fopen("tree.gv", "w");
  if(!f)
    printf("Can't open file\n");
  else
  {
    export_to_dot(f, "tree", root);
    fclose(f);
  }

  return 0;
}
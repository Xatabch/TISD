/*Цель работы – построить и обработать хеш-таблицы, 
сравнить эффективность поиска в сбалансированных деревьях, 
в двоичных деревьях поиска и в хеш-таблицах. 
Сравнить эффективность устранения коллизий при внешнем и внутреннем хешировании.*/

/*Задание: 
построить хеш-таблицу по указанным данным. 
Сравнить эффективность поиска в сбалансированном двоичном дереве, в двоичном дереве поиска и в хеш-таблице (используя открытую и закрытую адресацию). 
Вывести на экран деревья и хеш-таблицы. 
Подсчитать среднее количество сравнений для поиска данных в указанных структурах. 
Произвести реструктуризацию хеш-таблицы, если среднее количество сравнений больше указанного. 
Оценить эффективность использования этих структур (по времени и памяти) для поставленной задачи. 
Оценить эффективность поиска в хеш-таблице при различном количестве коллизий и при различных методах  их разрешения.*/

/*Используя предыдущую программу (задача №6), сбалансировать полученное дерево . Вывести его на экран в виде дерева.---
Построить хеш-таблицу из чисел файла.---
Осуществить поиск введенного целого числа в двоичном дереве поиска, в сбалансированном дереве и в хеш-таблице.--- 
Сравнить время поиска, объем памяти и количество сравнений при использовании различных структур данных.*/


#include <stdio.h>
#include <stdlib.h>

#include "main.h" //структуры
#include "insert.h"//вставка зла в двоичное дерево
#include "apply.h"//пямой обход дерева
#include "getnum.h"//получение чисел из файла и создание дерева.
#include "createdot.h"//создание .gv файла
#include "tick.h"//замер времени.
#include "rotateright.h"// правый поворот вокруг p
#include "rotateleft.h"// левый поворот вокруг q
#include "helpfunc.h"//вспомогательные функции для построения авл деревьев
#include "balance.h"//балансировка дерева
#include "insertavl.h"//функция вставки в балансированное дерево(пока что не требуется)
#include "balancetree.h"//балансировка дерева
#include "openhash.h"//хеш-таблица с использованием открытой адресации(метод цепочек)
#include "closehash.h"//хеш-таблица с использованием закрытой адрсации(линейная адресация)

int main(void)
{
  FILE *f;
  tree *root = NULL;
  Hashmap *map = NULL;
  int *arr = NULL;
  int size = 0;
  //tree *avl_root = NULL;

  f = fopen("in.txt","r");
  if(!f)
    printf("Can't open file\n");
  else
  {
    root = get_num(f);
    fclose(f);

    printf("\nПрямой обход несбалансированного дерева: ");
    apply_pre(root, print, "%d ");
    printf("\n");

    //создание сбалансировнного дерева
    // f = fopen("in.txt","r");
    // if(!f)
    //   printf("Can't open file\n");
    // else
    // {
    //   avl_root = get_avl_tree(f);
    //   fclose(f);
    //   printf("\nПрямой обход авл дерева: ");
    //   apply_pre(avl_root, print, "%d ");
    //   printf("\n\n");
    // }

     root = balance_tree(root);
     printf("\nПрямой обход авл дерева: ");
     apply_pre(root, print, "%d ");
     printf("\n");


    //Создание хеш-таблицы с использованием открытой адресаци(устранение коллизий методом цепочек)
    f = fopen("in.txt","r");
    if(!f)
      printf("Невозможно открыть файл\n");
    else
    {
      map = get_open_hash(f);
      fclose(f);
    }

    if(map)
    {
      printf("'Обход' хеш-таблицы с открытой адресацией:\n");
      mapIterate(map,printEntry, NULL);
    }
    //Проверка поиска в хеш-таблице открытой адресации(требуется последующее развитие данной реализации)
    int v = 0;
    v = get(map,16);
    if(v != -100000000)
      printf("\nЭлемент %d найден\n", v);
  }

  //Создание хеш-таблицы с использованием закрытой адресации
  f = fopen("in.txt","r");
  if(!f)
    printf("Невозможно открыть файл\n");
  else
  {
    arr = get_close_hash(arr,f,&size);
    fclose(f);
    printf("\n'Обход' хеш-таблицы с закрытой адресацией:\n");
    for(int i = 0; i < size; i++)
       printf("%d:%d\n", i, arr[i]);
    int v;
    int sravneniya = 0;
    v = get_close(arr,4,&size,&sravneniya);
    if(v != -10000000)
      printf("\nЭлемент %d найден\n\n", v);

  }
  f = fopen("tree.gv", "w");
  if(!f)
    printf("Can't open file\n");
  else
  {
    export_to_dot(f, "tree", root);
    fclose(f);
  }

  return 0;
}